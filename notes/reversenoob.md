

# General
.data
.bss
text -> machine

# strings
* `strings -e l` l | b | S changes encoding

# ltrace

* `ltrace binary`

# strace

* system calls

# ftrace

* function calls

# objdump
* objdump -M intel -D <binary> 

# gdb-pwdbg
* break funcname
## string compare 
* `gdb-pwdbg`
* `info functions`
* `disassemble main` -> if PI is enabled, you can't grab the address yet
* `disass <func>` -> displays pointers that can be broken `*0x080xxx`
* `break main` start the binary again `run` 
* `break *0x55555555273` where eax,0x0 is return 0 --> at the function like string compare
* 
* [b]reak <function name or filename:line # or <memory>
* `c` contiune (fast)
* `s` step next function
* `n` next (does not step in funcs) `nexti`
* `[x]/ <address>` examine (return address and converted value)
* * x/d <var>
* * x/x $ebp-4
* * x/x 0x55555555232
* x/<number of instructions> <addres> -> (x/128 &i) (x/128x &i)
* `print &<var>` print value of address
* * `p/d *0x5555555555273`
* `info registers`
* `info break`

# find return address 

* p $ebp-&buffer = ebp
* offset = ebp + 4
* 

# Format
d decmal 
t binary 
u unsigned 
x hex 
s string 
o octa

# Class
* ebp-4 = local variables
* ebp+4 = parameters

## break to function manually from ghidra
* copy number `015c3` from (001015c3) in ghidra holding the function
* `breakrva 0x015c3`
* `c` contiune

## Change a variable
* `break main` --> https://youtu.be/TN1zPbKN_9E?t=911
* `breakrva 0x14d9` varable from ghidra (001014d9)
* `c` contiune -> find where variable is set
* `n` next instruction
* `p $rbp - 0x8c` --> shows pointer holding variable
* `p *0x34354` replace with pointer res to check the varible is assigned
* `set *0x34354 = 2` set new value 
* `p *0x34354` --> to check
* `c` contiune

# Ghidara
* &DAT_000001 -> in data
* ^ 0x20 -> xor in 20 

# Radare

* `r2 binary`
* `aa` -> analyze
* `afl` -> show function
* `s main` go to function
* `pdf` -> diassemble
Read in Data section
* `iS` -> sections of the program with &DAT_ from ghidra
* get address from ghidra with &DAT_3223 `px 0x000024432`
* grab hex and decode with chyber cheff xor 20


# Pwn tools
replace ptrace funtion with return // can be any function (output is saved as patched)
```
from pwn import *

exe = 'binary'
elf = context.binary = ELF(exe, checksec=False)

pprint(elf.symbols)
elf.asm(elf.symbols.ptrace, 'ret')
elf.save('patched') 
```