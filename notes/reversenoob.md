
# ltrace

* `ltrace binary`

# gdb-pwdbg
* break funcname
## string compare 
* `gdb-pwdbg`
* `info functions`
* `disassemble main` -> if PI is enabled, you can't grab the address yet
* `break main` start the binary again `run`
* `break *0x55555555273` --> at the function like string compare
* `c` contiune

## break to function manually from ghidra
* copy number `015c3` from (001015c3) in ghidra holding the function
* `breakrva 0x015c3`
* `c` contiune

## Change a variable
* `break main` --> https://youtu.be/TN1zPbKN_9E?t=911
* `breakrva 0x14d9` varable from ghidra (001014d9)
* `c` contiune -> find where variable is set
* `n` next instruction
* `p $rbp - 0x8c` --> shows pointer holding variable
* `p *0x34354` replace with pointer res to check the varible is assigned
* `set *0x34354 = 2` set new value 
* `p *0x34354` --> to check
* `c` contiune

# Ghidara
* &DAT_000001 -> in data
* ^ 0x20 -> xor in 20 

# Radare

* `r2 binary`
* `aa` -> analyze
* `afl` -> show function
* `s main` go to function
* `pdf` -> diassemble
Read in Data section
* `iS` -> sections of the program with &DAT_ from ghidra
* get address from ghidra with &DAT_3223 `px 0x000024432`
* grab hex and decode with chyber cheff xor 20


# Pwn tools
replace ptrace funtion with return // can be any function (output is saved as patched)
```
from pwn import *

exe = 'binary'
elf = context.binary = ELF(exe, checksec=False)

pprint(elf.symbols)
elf.asm(elf.symbols.ptrace, 'ret')
elf.save('patched') 
```